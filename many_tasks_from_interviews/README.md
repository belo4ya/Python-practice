<details>
<summary> 1. Базовые типы данных </summary>

   - Неизменяемые:
   ```int```, ```float```, ```complex```, ```str```, ```bytes```, ```None```, ```bool```, ```tuple```, ```frozenset```
   - Изменяемые:
   ```dict```, ```list```, ```set```
</details>

<details>
<summary> 2. Побитовые операции </summary>

   ```python
a = 120        # 1111000
b = 100        # 1100100
print(a | b)   # 124  = 0b1111100
print(a ^ b)   # 28   = 0b11100
print(a & b)   # 96   = 0b1100000
print(a << 4)  # 1920 = 0b11110000000
print(a >> 4)  # 7    = 0b111
print(~a)      # -121 = -0b1111001
   ```
</details>

<details>
<summary> 3. Функциональное программирование </summary>
   
   - ```lambda```, ```zip```, ```map```, ```filter```, ```reduce``` (functools)

   ```python
numbers = range(10)
squared_evens = map(lambda n: n ** 2, filter(lambda n: n % 2 == 0, numbers))
list(squared_evens)  # [0, 4, 16, 36, 64]
   ```

   - Декораторы:
   
   ```python
from functools import wraps
    
def logger(filename):

    def decorator(func):

        @wraps(func)
        def wrapped(*args, **kwargs):
            result = func(*args, **kwargs)
            with open(filename, "w+") as f:
                f.write(str(result))
            return result

        return wrapped

    return decorator
   ```
</details>

<details>
<summary> 4. Генераторы, выражения-генераторы, иттераторы </summary>

   - Генератор - это функция содержащая ключевое слово ```yield```.
   Генераторы позволят осуществлять ленивые вычисления. Также является иттератором.
   
   ```python
def fibonacci(number):
    a = b = 1
    for _ in range(number):
        yield a
        a, b = b, a + b
   ```

   - Выражения-генераторы предназначены для компактного и удобного способа генерации коллекций элементов.
   
   ```python
iter_ = (i ** 2 if i % 2 == 0 else i for i in range(5))  # <generator object <genexpr> at 0x000002D0E5219660>
list_ = [i ** 2 for i in range(10) if i % 2 == 0]  # [0, 4, 16, 36, 64]
set_ = {i for i in range(0, 10, 2)}  # {0, 2, 4, 6, 8}
dict_ = {v: k for k, v in {'a': 1, 'b': 2, 'c': 3}.items()}  # {1: 'a', 2: 'b', 3: 'c'}
   ```
   
   - Итератор — это сущность порождаемая функцией iter, с помощью которой происходит итерирование итерируемого объекта. 
   Итерируемый объект — это что-то, что можно итерировать. Итератор не имеет индексов и может быть использован только один раз.
   
   ```python
# реализация с помощью генераторов

def infinity(step):
    i = 0
    while True:
        yield i
        i += step

iter_ = infinity(10)
next(iter_)  # 0
next(iter_)  # 10
next(iter_)  # 20
   ```

   ```python
# итерируемый объект

class Arrange:

    def __init__(self, start, stop, step):
        self.i = start
        self.stop = stop
        self.step = step

    def __iter__(self):
        return self

    def __next__(self):
        if self.i > self.stop:
            raise StopIteration

        result = self.i
        self.i += self.step
        return result
   ```
</details>

<details>
<summary> 5. ООП </summary>

   - Класс — это описание того, какими свойствами и поведением будет обладать объект. Объект — это экземпляр с собственным состоянием этих свойств.

   - Абстракция:
        - выделение главных, наиболее значимых характеристик предмета и отбрасывание второстепенных, незначительных.
   - Наследование:
        - позволяет описать новый класс на основе существующего (родительского). Повторное использование кода.
   - Полиморфизм
        - возможность работать с несколькими типами так, будто это один и тот же тип. При этом 
        поведение объектов будет разным.
   - Инкапсуляция
        - ограничение доступа к данным и возможностям их изменения путем сокрытия их в классе. (в python - договоренность)
</details>

<details>
<summary> [6. Магические методы (dunder методы)](https://docs.python.org/3/reference/datamodel.html#specialnames) </summary>

   - Специальные методы, с помощью которых можно добавить в ваши классы «магию». Обрамлены двумя нижними подчеркиваниями.
   - Конструирование и инициализация:
        - ```__new__(cls, [...)``` - первый метод, который будет вызван при инициализации объекта для его создания.
        - ```__init__(self, [...)``` - инициализатор класса. Ему передаётся всё, с чем был вызван первоначальный конструктор.
        - ```__del__(self)``` -  определяет поведение объекта в то время, когда объект попадает в сборщик мусора.
   - Магические методы сравнения:
        - ```__cmp__(self, other)``` - базовый метод сравнения. Отрицательное число, если self < other, 
        ноль, если self == other, и положительное число в случае self > other.
        - ```__eq__(self, other)``` - определяет поведение оператора равенства, ==.
        - ```__ne__(self, other)``` - определяет поведение оператора неравенства, !=.
        - ```__lt__(self, other)``` - определяет поведение оператора меньше, <.
        - ```__gt__(self, other)``` - определяет поведение оператора больше, >.
        - ```__le__(self, other)``` - определяет поведение оператора меньше или равно, <=.
        - ```__ge__(self, other)``` - определяет поведение оператора больше или равно, >=.
   - Унарные операторы и функции:
        - ```__pos__(self)``` - определяет поведение для унарного плюса (+some_object).
        - ```__neg__(self)``` - определяет поведение для отрицания(-some_object).
        - ```__abs__(self)``` - определяет поведение для встроенной функции abs().
        - ```__invert__(self)``` - определяет поведение для инвертирования оператором ~.
        - ```__round__(self, n)``` - определяет поведение для встроенной функции round().
        - ```__floor__(self)``` - определяет поведение для math.floor().
        - ```__ceil__(self)``` - определяет поведение для math.ceil().
        - ```__trunc__(self)``` - определяет поведение для math.trunc().
   - Обычные арифметические операторы:
        - ```__add__(self, other)``` - сложение.
        - ```__sub__(self, other)``` - вычитание.
        - ```__mul__(self, other)``` - умножение.
        - ```__floordiv__(self, other)``` - целочисленное деление, оператор //.
        - ```__div__(self, other)``` - деление, оператор /.
        - ```__truediv__(self, other)``` - правильное деление. ```from __future__ import division```
        - ```__mod__(self, other)``` - остаток от деления, оператор %.
        - ```__divmod__(self, other)``` - определяет поведение для встроенной функции divmod().
        - ```__pow__(self, power, modulo)``` - возведение в степень, оператор **.
        - ```__lshift__(self, other)``` - двоичный сдвиг влево, оператор <<.
        - ```__rshift__(self, other)``` - двоичный сдвиг вправо, оператор >>.
        - ```__and__(self, other)``` - двоичное И, оператор &.
        - ```__or__(self, other)``` - двоичное ИЛИ, оператор |.
        - ```__xor__(self, other)``` - двоичный xor, оператор ^.
   - Отражённые арифметические операторы:
        - ```__radd__(self, other)``` - отражённое сложение.
        - `__r...` - см. предыдущий пункт.
   - Составное присваивание:
        - ```__iadd__(self, other)``` - сложение с присваиванием.
        - `__r...` - см. пункт "Обычные арифметические операторы".
   - Магические методы преобразования типов:
        - ```__int__(self)``` - преобразование типа в int.
        - ```__float__(self)``` - преобразование типа в float.
        - ```__complex__(self)``` - преобразование типа в комплексное число.
        - ```__oct__(self)``` - преобразование типа в восьмеричное число.
        - ```__hex__(self)``` - преобразование типа в шестнадцатиричное число.
        - ```__index__(self)``` - преобразование типа к int, когда объект используется в срезах.
        - ```__trunc__(self)``` - вызывается при math.trunc(self).
        
   

</details>

    







4. Вирутуальное окружение:
    - ```python -m venv "env"```

- KISS, DRY, SOLID, CRUD, REST, SOAP

