<details>
<summary> <b>Python</b> </summary>

<details>
<summary> 1. Базовые типы данных </summary>

   - Неизменяемые:
   ```int```, ```float```, ```complex```, ```str```, ```bytes```, ```None```, ```bool```, ```tuple```, ```frozenset```
   - Изменяемые:
   ```dict```, ```list```, ```set```
</details>

<details>
<summary> 2. Побитовые операции </summary>

   ```python
a = 120        # 1111000
b = 100        # 1100100
print(a | b)   # 124  = 0b1111100
print(a ^ b)   # 28   = 0b11100
print(a & b)   # 96   = 0b1100000
print(a << 4)  # 1920 = 0b11110000000
print(a >> 4)  # 7    = 0b111
print(~a)      # -121 = -0b1111001
   ```
</details>

<details>
<summary> 3. Функциональное программирование </summary>
   
   - ```lambda```, ```zip```, ```map```, ```filter```, ```reduce``` (functools)

   ```python
numbers = range(10)
squared_evens = map(lambda n: n ** 2, filter(lambda n: n % 2 == 0, numbers))
list(squared_evens)  # [0, 4, 16, 36, 64]
   ```

   - Декораторы:
   
   ```python
from functools import wraps
    
def logger(filename):

    def decorator(func):

        @wraps(func)
        def wrapped(*args, **kwargs):
            result = func(*args, **kwargs)
            with open(filename, "w+") as f:
                f.write(str(result))
            return result

        return wrapped

    return decorator
   ```
</details>

<details>
<summary> 4. Генераторы, выражения-генераторы, иттераторы </summary>

   - Генератор - это функция содержащая ключевое слово ```yield```.
   Генераторы позволят осуществлять ленивые вычисления. Также является иттератором.
   
   ```python
def fibonacci(number):
    a = b = 1
    for _ in range(number):
        yield a
        a, b = b, a + b
   ```

   - Выражения-генераторы предназначены для компактного и удобного способа генерации коллекций элементов.
   
   ```python
iter_ = (i ** 2 if i % 2 == 0 else i for i in range(5))  # <generator object <genexpr> at 0x000002D0E5219660>
list_ = [i ** 2 for i in range(10) if i % 2 == 0]  # [0, 4, 16, 36, 64]
set_ = {i for i in range(0, 10, 2)}  # {0, 2, 4, 6, 8}
dict_ = {v: k for k, v in {'a': 1, 'b': 2, 'c': 3}.items()}  # {1: 'a', 2: 'b', 3: 'c'}
   ```
   
   - Итератор — это сущность порождаемая функцией iter, с помощью которой происходит итерирование итерируемого объекта. 
   Итерируемый объект — это что-то, что можно итерировать. Итератор не имеет индексов и может быть использован только один раз.
   
   ```python
# реализация с помощью генераторов

def infinity(step):
    i = 0
    while True:
        yield i
        i += step

iter_ = infinity(10)
next(iter_)  # 0
next(iter_)  # 10
next(iter_)  # 20
   ```

   ```python
# итерируемый объект

class Arrange:

    def __init__(self, start, stop, step):
        self.i = start
        self.stop = stop
        self.step = step

    def __iter__(self):
        return self

    def __next__(self):
        if self.i > self.stop:
            raise StopIteration

        result = self.i
        self.i += self.step
        return result
   ```
</details>

<details>
<summary> 5. ООП </summary>

   - Класс — это описание того, какими свойствами и поведением будет обладать объект. Объект — это экземпляр с собственным состоянием этих свойств.

   - Абстракция:
        - выделение главных, наиболее значимых характеристик предмета и отбрасывание второстепенных, незначительных.
   - Наследование:
        - позволяет описать новый класс на основе существующего (родительского). Повторное использование кода.
   - Полиморфизм
        - возможность работать с несколькими типами так, будто это один и тот же тип. При этом 
        поведение объектов будет разным.
   - Инкапсуляция
        - ограничение доступа к данным и возможностям их изменения путем сокрытия их в классе. (в python - договоренность)
</details>

<details>
<summary> 6. Магические методы (dunder методы) </summary>

   - [Специальные методы](https://docs.python.org/3/reference/datamodel.html#specialnames), с помощью которых можно добавить в ваши классы «магию». 
   Обрамлены двумя нижними подчеркиваниями. Некоторые из них:
   - Конструирование и инициализация:
        - `__new__(cls, [...)` - первый метод, который будет вызван при инициализации объекта для его создания.
        - `__init__(self, [...)` - инициализатор класса. Ему передаётся всё, с чем был вызван первоначальный конструктор.
        - `__del__(self)` -  определяет поведение объекта в то время, когда объект попадает в сборщик мусора.
   - Магические методы сравнения:
        - `__eq__(self, other)` - определяет поведение оператора равенства, ==.
        - `__ne__(self, other)` - определяет поведение оператора неравенства, !=.
        - `__lt__(self, other)` - определяет поведение оператора меньше, <.
        - `__gt__(self, other)` - определяет поведение оператора больше, >.
        - `__le__(self, other)` - определяет поведение оператора меньше или равно, <=.
        - `__ge__(self, other)` - определяет поведение оператора больше или равно, >=.
   - Унарные операторы и функции:
        - `__pos__(self)` - определяет поведение для унарного плюса (+some_object).
        - `__neg__(self)` - определяет поведение для отрицания(-some_object).
        - `__abs__(self)` - определяет поведение для встроенной функции abs().
   - Обычные арифметические операторы:
        - `__add__(self, other)` - сложение.
        - `__sub__(self, other)` - вычитание.
        - `__mul__(self, other)` - умножение.
   - Отражённые арифметические операторы:
        - `__radd__(self, other)` - отражённое сложение.
        - `__r...` - см. предыдущий пункт.
   - Составное присваивание:
        - `__iadd__(self, other)` - сложение с присваиванием.
        - `__i...` - см. пункт "Обычные арифметические операторы".
   - Магические методы преобразования типов:
        - `__int__(self)` - преобразование типа в int.
        - `__float__(self)` - преобразование типа в float.
        - `__complex__(self)` - преобразование типа в комплексное число.
        - `__oct__(self)` - преобразование типа в восьмеричное число.
        - `__hex__(self)` - преобразование типа в шестнадцатиричное число.
        - `__index__(self)` - преобразование типа к int, когда объект используется в срезах.
   - Представление своих классов:
        - `__str__(self)` - определяет поведение функции `str()`.
        - `__repr__(self)` - определяет поведение функции `repr()`.
        - `__hash__(self)` - определяет поведение функции `hash()`.
        - `__dir__(self)` - определяет поведение функции `dir()`.
        - `__sizeof__(self)` - определяет поведение функции `sys.getsizeof()`.
   - Контроль доступа к атрибутам:
        - `__getattr__(self, name)` - определяет поведение для случая, 
        когда пользователь пытается обратиться к атрибуту, который не существует.
        - `__setattr__(self, name, value)` - определяет поведение для присвоения значения атрибуту.
        - `__delattr__` - то же, что и __setattr__, но для удаления атрибутов, вместо установки значений.
   - Магия контейнеров:
        - `__len__(self)` - возвращает количество элементов в контейнере.
        - `__getitem__(self, key)` - определяет поведение при доступе к элементу, используя синтаксис `self[key]`.
        - `__setitem__(self, key, value)` - определяет поведение при присваивании значения элементу, 
        используя синтаксис `self[key] = value`.
        - `__delitem__(self, key)` - определяет поведение при удалении элемента (то есть `del self[key]`).
        - `__iter__(self)` - должен вернуть итератор для контейнера.
        - `__reversed__(self)` - вызывается чтобы определить поведения для встроенной функции `reversed()`.
        - `__contains__(self, item)` - предназначен для проверки принадлежности элемента с помощью `in` и `not in`.
        - `__missing__(self, key)` - определяет поведение , когда пользователь пытается получить 
        элемент по несуществующему ключу.
   - Вызываемые объекты:
        - `__call__` - означает, что `x()` означает то же, что и `x.__call__()`.
   - Менеджеры контекста:
        - `__enter__(self)` - определяет, что должен сделать менеджер контекста в начале блока, 
        созданного оператором `with`. Возвращаемое `__enter__` значение 
        и есть то значение, с которым производится работа внутри `with`.
        - `__exit__(self, ex_type, ex_value, tb)` - определяет действия менеджера контекста 
        после того, как блок будет выполнен.
   - Построение дескрипторов:
        - Дескрипторы это такие классы, с помощью которых можно добавить свою логику к событиям доступа 
        (получение, изменение, удаление) к атрибутам других объектов.
        - `__get__(self, instance, instance_class)` - определяет поведение при возвращении значения из дескриптора.
        - `__set__(self, instance, value)` - определяет поведение при изменении значения из дескриптора.
        - `__delete__(self, instance)` - определяет поведение для удаления значения из дескриптора.
   - Копирование:
        - `__copy__(self)` - определяет поведение `copy.copy()`.
        - `__deepcopy__(self, memodict={})` - определяет поведение `copy.deepcopy()`.
</details>

</details>



<details>
<summary><b> KISS, DRY, YAGNI, SOLID </b></summary>

<details>
<summary>KISS</summary>

Принцип проектирования **KISS( **keep it simple stupid 
(keep it simple and straightforward))** провозглашает, что простота кода – 
превыше всего, потому что простой код – наиболее понятный. 

> Патерны проектирования описывают наиболее удачные, простые и понятные 
решения некоторых проблем. Если вы используете паттерн проектирования 
там, где нет проблемы, которую решает данный паттерн – то вы нарушаете 
KISS, внося ненужные усложнения в код. Если вы НЕ используете паттерн 
проектирования там, где есть проблема, соответствующая паттерну – то 
вы опять-таки нарушаете KISS, делая код сложнее, чем он мог бы быть.
</details>

<details>
<summary>DRY</summary>

**DRY – Don’t repeat yourself (не повторяй себя)**.

> Когда вы разрабатываете крупный проект, часто приходится сталкиваться 
с избыточной общей сложностью реализации. Люди плохо справляются с 
управлением сложных систем, им лучше удается находить необычные решения 
определенных задач. Самое простое решение по уменьшению сложности – 
разделить систему на мелкие, независимые модули, которыми проще управлять.
</details>

<details>
<summary>YAGNI</summary>

> dsada
</details>

<details>
<summary>SOLID</summary>

> dsada
</details>

</details>
